#!/usr/bin/python

import datetime, time
import random
import argparse
import os

DATE_FORMAT = '%Y-%m-%d %H:%M:%S'

# http://stackoverflow.com/a/553320/769384
def str_time_prop(start, end, format, prop):
    """Get a time at a proportion of a range of two formatted times.
    start and end should be strings specifying times formated in the
    given format (strftime-style), giving an interval [start, end].
    prop specifies how a proportion of the interval to be taken after
    start.  The returned time will be in the specified format.
    """
    stime = time.mktime(time.strptime(start, format))
    etime = time.mktime(time.strptime(end, format))
    ptime = stime + prop * (etime - stime)
    return time.strftime(format, time.localtime(ptime))

def random_from_to_datetime(start, end, prop):
    return str_time_prop(start, end, DATE_FORMAT, prop)

def generate_random_counts():
    return {
        'income': random.randint(1000, 2000),
        'outcome': random.randint(5000, 7000)
    }

def path(prefix, filename):
    return os.path.join(prefix, filename)

def dump_content(content, filepath):
    f = open(filepath, 'w')
    f.write(content)
    f.close()

def summary(files):
    content = 'Following files generated successfully:' + ''.join('\n - ' + f for f in files)
    print content

def generate_values():
    result_values = {
        'users': USERS,
        'category': CATEGORIES
    }

    counts = generate_random_counts()
    str_begin, str_end = '2000-1-1 00:00:00', time.strftime(DATE_FORMAT)

    filter_categories = lambda category_type: [row for row in CATEGORIES if row[3] == category_type]
    random_user = lambda: random.choice(result_values['users'])
    random_income_category = lambda: random.choice(income_categories)
    random_outcome_category = lambda: random.choice(outcome_categories)
    random_date = lambda: random_from_to_datetime(str_begin, str_end, random.random())

    tmp_incomes = []
    income_categories = filter_categories('income')
    for _id in range(1, counts['income']):
        tmp_user = random_user()
        tmp_category = random_income_category()
        tmp_amount = random.uniform(random.randint(100, 200), random.randint(100, 1000) * 2)
        tmp_incomes.append((
            _id, tmp_category[0], tmp_amount,
            '%0.2f earned for %s stuff by %s' % (tmp_amount, tmp_category[2], tmp_user[1] + ' ' + tmp_user[2]),
            random_date(), tmp_user[0]
        ))
    result_values['income'] = tmp_incomes

    tmp_outcomes = []
    outcome_categories = filter_categories('outcome')
    for _id in range(1, counts['outcome']):
        tmp_user = random_user()
        tmp_category = random_outcome_category()
        tmp_amount = random.uniform(random.randint(10, 200), random.randint(100, 500))
        tmp_outcomes.append((
            _id, tmp_category[0], tmp_amount,
            '%0.2f spent for %s stuff by %s' % (tmp_amount, tmp_category[2], tmp_user[1] + ' ' + tmp_user[2]),
            random_date(), tmp_user[0]
        ))
    result_values['outcome'] = tmp_outcomes

    return result_values

def generate_sql():
    raw = generate_values()
    config = {
        'host': 'localhost',
        'dbname': 'duck_database',
        'dbuser': 'duck_user',
        'password': 'wXyqhWzlF0uO20j8'
    }
    order = ['users', 'category', 'income', 'outcome']
    files = []

    filepath = path('sql', 'fixtures.sql')
    fixtures = 'USE `%s`;\n\n' % (config['dbname'],)
    for table in order:
        fields = ', '.join('`%s`' % (field) for field in SCHEMA[table])
        values = []
        for row in raw[table]:
            row = ('\'' + str(cell) + '\'' if cell else 'NULL' for cell in row)
            values.append('(' + ', '.join(row) + ')')
        values = ',\n'.join(values)
        fixtures += 'INSERT INTO `%s` (%s) VALUES\n%s;\n\n' % (table, fields, values)
    dump_content(fixtures, filepath)
    files.append(filepath)

    filepath = path('sql', 'access.sql')
    access = "CREATE USER '%s'@'%s' IDENTIFIED BY '%s';\n" % (config['dbuser'], config['host'], config['password'])
    access += "GRANT ALL PRIVILEGES ON `%s`.* TO '%s'@'%s'\n" % (config['dbname'], config['dbuser'], config['host'])
    access += 'WITH GRANT OPTION;\n'
    dump_content(access, filepath)
    files.append(filepath)

    summary(files)

def generate_json(wrap=True):
    import json
    files = []
    for filetype, raw in generate_values().iteritems():
        schema = SCHEMA[filetype]
        values = [dict(zip(schema, v)) for v in raw]
        if wrap:
            values = { 'objects': values }
        filepath = path('json', filetype + '.json')
        dump_content(json.dumps(values), filepath)
        files.append(filepath)
    summary(files)

#==============================================================================

parser = argparse.ArgumentParser(prog="Wealthy Laughing Duck fixtures generator")
parser.add_argument('format', help='sql or json')
#parser.add_argument('-w', '--wrap-json-objects', help='wrap json output in "objects" key')
parser.add_argument('-V', '--version', action='version', version='%(prog)s 1.0.0-ALPHA')
args = parser.parse_args()

output_format = args.format.lower()
if output_format in ('sql', 'json'):
    random.seed()
    from const import SCHEMA, USERS, CATEGORIES

    if output_format == 'sql':
        generate_sql()
    elif output_format == 'json':
        generate_json()
else:
    raise Exception("Unsupported format %s" % (output_format,))
